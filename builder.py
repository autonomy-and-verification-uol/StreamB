from antlr4 import *
from StreamLexer import StreamLexer
from StreamParser import StreamParser
from StreamVisitor import StreamVisitor
import re
import os, shutil, stat

class StreamBuilder(StreamVisitor):

    def __init__(self):
        super().__init__()
        self.num = 0
        self.nMonitors = 0
        self.types = {}
        self.subscribers = set()
        self.type = None
        self.precision = 1.0
        self.rate = 10
        self.threshold = 2
        self.debug = False
        self.already_seen = {}

    def reset(self):
        self.initialization = list()
        self.statements = list()
        self.variables = set()
        self.output = set()
        self.subscribers = set()
        self.num = 0

    # convert type from Grammar to timed type in ROS
    def convertToTimed(type):
        if type == 'int':
            ty = 'TimedInt'
        elif type == 'real':
            ty = 'TimedReal'
        else:
            ty = 'TimedBool'
        return ty

    # convert type from Grammar to type in ROS
    def convert(type):
        if type == 'TimedInt':
            ty = 'Int64'
        elif type == 'TimedReal':
            ty = 'Float64'
        else:
            ty = 'Bool'
        return ty

    # create the launch file for all the monitors generated by the builder
    def createLaunch(self):
        statements = []
        statements += ['<launch>']
        #statements += ['\t<node pkg="monitor" type="clockNode.py" name="clockNode" output="screen"/>']
        for filename in os.listdir('./monitors/'):
            statements += ['\t<node pkg="stream" type="{fn}" name="{id}" output="screen"/>'.format(fn=filename, id=filename[:-3])]
            st = os.stat('./monitors/' + filename)
            os.chmod('./monitors/' + filename, st.st_mode | stat.S_IEXEC)
        statements += ['</launch>']
        source = '\n'.join(statements)
        with open('./monitors/run.launch', 'w') as launch_file:
            launch_file.write(source)

    # create a composition monitor
    def createCompositionMonitor(self, monitorName, labelL, labelR, typeL, typeR, operator):
        # imports all things necessary
        statements = []
        statements += ['#!/usr/bin/env python']
        statements += ['import rospy']
        statements += ['import sys']
        statements += ['from sortedcontainers import SortedDict']
        statements += ['from threading import *']
        statements += ['from stream.msg import *']
        statements += ['from std_msgs.msg import *']
        statements += ['']
        statements += ['ws_lock = Lock()']
        statements += ['']
        # if the left and right components are composed create the dictionary to keep track of the msgs
        if labelL.startswith('kwargs') and labelR.startswith('kwargs'):
            statements += ['dict_msgs = SortedDict()']
        # if the left component is composed, we have to subscribe to its monitor
        if labelL.startswith('kwargs'):
            statements += ['def callback{topic}(data):'.format(topic=labelL[8:-2])]
            statements += ['\tws_lock.acquire()']
            # if also the right component is composed, we have to call the conditional_publish method
            if labelR.startswith('kwargs'):
                statements += ['\tif data.time not in dict_msgs:']
                statements += ['\t\tdict_msgs[data.time] = set()']
                statements += ['\tdict_msgs[data.time].add((\'l\', data.value))']
                statements += ['\tconditional_publish()']
            else: # otherwise, we already have everything we need
                statements += ['\tmsg = TimedBool()']
                statements += ['\tmsg.time = data.time'] # propagate the same time
                statements += ['\tmsg.value = data.value {op} {labelR}'.format(op=operator,labelR=labelR)] # evaluate using the given operator
                if self.debug:
                    statements += ['\tprint(str(data.value) + \' {op} \' + str({labelR}) + \'=\' + str(msg.value))'.format(op=operator, labelR=labelR)]
                statements += ['\tpub.publish(msg)'] # publish the message (we do not need to wait for the right component, because it is constant)
            statements += ['\tws_lock.release()']
        # symmetrically as before, but for the right component
        if labelR.startswith('kwargs'):
            statements += ['def callback{topic}(data):'.format(topic=labelR[8:-2])]
            statements += ['\tws_lock.acquire()']
            if labelL.startswith('kwargs'):
                statements += ['\tif data.time not in dict_msgs:']
                statements += ['\t\tdict_msgs[data.time] = set()']
                statements += ['\tdict_msgs[data.time].add((\'r\', data.value))']
                statements += ['\tconditional_publish()']
            else:
                statements += ['\tmsg = TimedBool()']
                statements += ['\tmsg.time = data.time']
                statements += ['\tmsg.value = {labelL} {op} data.value'.format(op=operator,labelL=labelL)]
                if self.debug:
                    statements += ['\tprint(str({labelL}) + \' {op} \' + str(data.value) + \'=\' + str(msg.value))'.format(op=operator, labelL=labelL)]
                statements += ['\tpub.publish(msg)']
            statements += ['\tws_lock.release()']
        statements += ['']
        # if both the components are composed, we need to define the conditional_publish method
        # We keep track of the msgs throgh bags of them ordered according to theit time.
        # This allows us to handle lost messages and unordered ones.
        # When a bag of msgs is full, meaning that all the info we are waiting for that msg
        # are arrived, we can publish and propagate the corresponding result.
        # If other msgs arrive before the oldest bag of msgs is full, we simply add the new
        # bag of msgs. If after the threshold we still have not published the first bag of messages,
        # it measn something went wrong, and we lost some message. Thus, we remove the first and oldest bag
        # of msgs, and we go on with the other ones.
        if labelL.startswith('kwargs') and labelR.startswith('kwargs'):
            statements += ['attempts = 0']
            statements += ['def conditional_publish():']
            statements += ['\tglobal attempts']
            statements += ['\tif len(dict_msgs.peekitem(0)[1]) == 2:'] # if the oldest bag of messages is full, we can publish the result
            if self.debug:
                statements += ['\t\tprint(dict_msgs)']
            statements += ['\t\te1 = dict_msgs.peekitem(0)[1].pop()'] # extract result from one component (random)
            statements += ['\t\te2 = dict_msgs.peekitem(0)[1].pop()'] # extratc result from one component (random)
            statements += ['\t\tmsg = TimedBool()']
            statements += ['\t\tmsg.time = dict_msgs.peekitem(0)[0]']
            statements += ['\t\tif e1[0] == \'l\':'] # identify which component is which
            statements += ['\t\t\tmsg.value = (e1[1] {op} e2[1])'.format(op=operator)]
            if self.debug:
                statements += ['\t\t\tprint(str(e1[1]) + \' {op} \' + str(e2[1]) + \'=\' + str(msg.value))'.format(op=operator)]
            statements += ['\t\telse:']
            statements += ['\t\t\tmsg.value = (e2[1] {op} e1[1])'.format(op=operator)]
            if self.debug:
                statements += ['\t\t\tprint(str(e2[1]) + \' {op} \' + str(e1[1]) + \'=\' + str(msg.value))'.format(op=operator)]
            statements += ['\t\tpub.publish(msg)']
            statements += ['\t\tdict_msgs.popitem(0)']
            statements += ['\t\tattempts = 0']
            statements += ['\telif attempts > {th}:'.format(th=(2*self.threshold))] # otherwise, we count the times we are waiting for the fisrt bag of msgs to be completed, if more than threshold, then remove the first bag of msgs
            statements += ['\t\tattempts = 0']
            statements += ['\t\tdict_msgs.popitem(0)']
            statements += ['\telse:']
            statements += ['\t\tattempts += 1']
        statements += ['']
        statements += ['def main(argv):']
        statements += ['\tglobal pub, monitor']
        statements += ['\trospy.init_node(\'{monitorName}\', anonymous=True)'.format(monitorName=monitorName)]
        statements += ['\tpub = rospy.Publisher(name = \'{topic}\', data_class = {ty}, latch = True, queue_size = 1000)'.format(topic=monitorName, ty=self.type)]
        if labelL.startswith('kwargs'):
            statements += ['\trospy.Subscriber(\'{topic}\', {ty}, callback{topic})'.format(topic=labelL[8:-2], ty=typeL)]
        if labelR.startswith('kwargs'):
            statements += ['\trospy.Subscriber(\'{topic}\', {ty}, callback{topic})'.format(topic=labelR[8:-2], ty=typeR)]
        statements += ['\trospy.spin()']
        statements += ['']
        statements += ['if __name__ == \'__main__\':']
        statements += ['\tmain(sys.argv)']

        source = '\n'.join(statements)

        with open('./monitors/' + monitorName + '.py', 'w') as monitor:
            monitor.write(source)

    # create the aggregation monitor to aggregate the result obtained by a lower level monitor
    def createAggregationMonitor(self, monitorName, aggrFunc, type, child):
        # imports necessary
        statements = []
        statements += ['#!/usr/bin/env python']
        statements += ['import rospy']
        statements += ['import sys']
        statements += ['from threading import *']
        statements += ['from stream.msg import *']
        statements += ['from std_msgs.msg import *']
        statements += ['from queue import *']
        statements += ['import math']
        statements += ['']
        statements += ['ws_lock = Lock()']
        statements += ['']
        # we add the aggregate function which is passed as argument to the function
        # this helps resuing the code and making it easier to customize for future updates
        statements += [aggrFunc]
        # we add the callback to listen to the results obtained by the lower level monitor
        statements += ['def callback{topic}(data):'.format(topic=child[8:-2])]
        statements += ['\tws_lock.acquire()']
        statements += ['\tmsg = {type}()'.format(type=type)]
        statements += ['\tmsg.time = data.time']
        statements += ['\tmsg.value = aggregate(data.time, data.value)'] # aggreagte the result accordingly
        statements += ['\tpub.publish(msg)']
        if self.debug:
            statements += ['\tprint(\'aggregate(\' + str(data.value) + \') = \' + str(msg.value))']
        statements += ['\tws_lock.release()']
        statements += ['def main(argv):']
        statements += ['\tglobal pub, monitor']
        statements += ['\trospy.init_node(\'{monitorName}\', anonymous=True)'.format(monitorName=monitorName)]
        statements += ['\tpub = rospy.Publisher(name = \'{topic}\', data_class = {type}, latch = True, queue_size = 1000)'.format(topic=monitorName, type=type)]
        statements += ['\trospy.Subscriber(\'{topic}\', {ty}, callback{topic})'.format(topic=child[8:-2], ty=type)]
        statements += ['\trospy.spin()']
        statements += ['']
        statements += ['if __name__ == \'__main__\':']
        statements += ['\tmain(sys.argv)']

        source = '\n'.join(statements)

        with open('./monitors/' + monitorName + '.py', 'w') as monitor:
            monitor.write(source)

    # create the clock node to give the time
    # thanks to this node, we do not care about the information speed, because
    # all opur monitors follow the clock to intercept and propagate the information
    def createClockNode(self):
        statements = []
        statements += ['#!/usr/bin/env python']
        statements += ['import rospy']
        statements += ['import sys']
        statements += ['from stream.msg import *']
        statements += ['from std_msgs.msg import *']
        statements += ['']
        statements += ['def main(argv):']
        statements += ['\trospy.init_node(\'clockNode\', anonymous=True)']
        statements += ['\tpub = rospy.Publisher(name = \'stream_clock\', data_class = Int64, latch = True, queue_size = 1000)']
        statements += ['\trate = rospy.Rate({rate})'.format(rate=self.rate)]
        statements += ['\tcount = 0']
        statements += ['\twhile not rospy.is_shutdown():']
        statements += ['\t\tpub.publish(count)']
        statements += ['\t\tcount += 1']
        statements += ['\t\trate.sleep()']
        statements += ['']
        statements += ['if __name__ == \'__main__\':']
        statements += ['\tmain(sys.argv)']

        source = '\n'.join(statements)

        with open('./monitors/clockNode.py', 'w') as monitor:
            monitor.write(source)

    # create a MTL monitor
    def createMTLMonitor(self):
        classname = 'mtl_monitor_' + str(self.nMonitors)

        statements = []
        statements += ['#!/usr/bin/env python']
        statements += ['import rospy']
        statements += ['import intervals']
        statements += ['import sys']
        statements += ['from threading import *']
        statements += ['from stream.msg import *']
        statements += ['from std_msgs.msg import *']
        statements += ['from sortedcontainers import *']
        statements += ['']
        statements += ['ws_lock = Lock()']
        statements += ['']
        statements += ['class BaseMonitor:']
        statements += ['\tdef update_timed_since_inf(self, now, state, left, right, lower):']
        statements += ['\t\tif left and right:']
        statements += ['\t\t\treturn (state & intervals.closed(self.time, intervals.inf)) | intervals.closed(self.time + lower, intervals.inf)']
        statements += ['\t\telif not left and right:']
        statements += ['\t\t\treturn intervals.closed(self.time + lower, intervals.inf)']
        statements += ['\t\telif left and not right:']
        statements += ['\t\t\treturn (state & intervals.closed(self.time, intervals.inf))']
        statements += ['\t\telse:']
        statements += ['\t\t\treturn intervals.empty()']
        statements += ['\tdef update_timed_since(self, now, state, left, right, lower, upper):']
        statements += ['\t\tif left and right:']
        statements += ['\t\t\treturn (state & intervals.closed(self.time, intervals.inf)) | intervals.closed(self.time + lower, self.time + upper)']
        statements += ['\t\telif not left and right:']
        statements += ['\t\t\treturn intervals.closed(self.time + lower, self.time + upper)']
        statements += ['\t\telif left and not right:']
        statements += ['\t\t\treturn (state & intervals.closed(self.time, intervals.inf))']
        statements += ['\t\telse:']
        statements += ['\t\t\treturn intervals.empty()']
        statements += ['\tdef output_timed(self, state):']
        statements += ['\t\treturn self.time in state']
        statements += ['']
        statements += ['class {classname}(BaseMonitor):'.format(classname=classname)]
        statements += ['']
        statements += ['\ttime = -1']
        statements += ['\tstates = [{}]'.format(', '.join([str(init) for init in self.initialization]))]
        statements += ['']
        statements += ['\tdef update(self, **kwargs):']
        statements += ['']
        statements += ['\t\tself.time = self.time + 1']
        statements += ['\t\t{}'.format(statement) for statement in self.statements]
        statements += ['']
        statements += ['\t\treturn {}'.format(self.output)]
        statements += ['']
        statements += ['\tdef output(self):']
        statements += ['\t\treturn {}'.format(self.output)]
        statements += ['']
        #statements += ['dict_topic = {']
        # extract the topics of interest (we need to subscribe to all the lower monitors providing the info we need in the MTL property)
        subscribers = set()
        for statement in self.statements:
            for m in re.finditer('kwargs\[\'', statement):
                subscribers.add(statement[m.end():(m.end() + statement[m.end():].find('\']'))])
        for m in re.finditer('kwargs\[\'', self.output):
            subscribers.add(self.output[m.end():(m.end() + self.output[m.end():].find('\']'))])
        # i = 0
        # for subscriber in subscribers:
        #     i =+ 1
        #     if i != len(subscribers):
        #         statements += ['\t\'{topic}\' : False,'.format(topic=subscriber)]
        #     else:
        #         statements += ['\t\'{topic}\' : False'.format(topic=subscriber)]
        # statements += ['}']
        statements += ['']
        statements += ['dict_msgs = SortedDict()']
        # create callbacks for each one of them
        for subscriber in subscribers:
            statements += ['def callback{topic}(data):'.format(topic=subscriber)]
            statements += ['\tws_lock.acquire()']
            statements += ['\tif data.time not in dict_msgs:']
            statements += ['\t\tdict_msgs[data.time] = set()']
            statements += ['\tdict_msgs[data.time].add((\'{topic}\', data.value))'.format(topic=subscriber)]
            statements += ['\tconditional_publish()']
            statements += ['\tws_lock.release()']
        statements += ['']
        # we need a conditional publish as for the composition monitor
        # we create bags of msgs ordered in time, and we propagate the results
        # when we have the oldest bag of msgs full. Otherwise, after a certain amount
        # of attemps, we give up and go on with the next bag of msgs.
        statements += ['attempts = 0']
        statements += ['def conditional_publish():']
        statements += ['\tglobal attempts']
        statements += ['\tif len(dict_msgs.peekitem(0)[1]) == {l}:'.format(l=len(subscribers))]
        statements += ['\t\tkw = {}']
        statements += ['\t\tfor (topic,value) in dict_msgs.peekitem(0)[1]:']
        statements += ['\t\t\tkw[topic] = value']
        statements += ['\t\tmsg = TimedBool()']
        statements += ['\t\tmsg.time = dict_msgs.peekitem(0)[0]']
        statements += ['\t\tmsg.value = monitor.update(**kw)']
        statements += ['\t\tpub.publish(msg)']
        statements += ['\t\tdict_msgs.popitem(0)']
        statements += ['\t\tattempts = 0']
        statements += ['\telif attempts > {th}:'.format(th=(len(subscribers)*self.threshold))]
        statements += ['\t\tattempts = 0']
        statements += ['\t\tdict_msgs.popitem(0)']
        statements += ['\telse:']
        statements += ['\t\tattempts += 1']
        statements += ['def main(argv):']
        statements += ['\tglobal pub, monitor']
        statements += ['\trospy.init_node(\'{classname}\', anonymous=True)'.format(classname=classname)]
        statements += ['\tmonitor = {classname}()'.format(classname=classname)]
        for subscriber in subscribers:
            #ty = StreamBuilder.convertToTimed(subscriber)
            statements += ['\trospy.Subscriber(\'{topic}\', TimedBool, callback{topic})'.format(topic=subscriber)]
        statements += ['\tpub = rospy.Publisher(name = \'{topic}\', data_class = TimedBool, latch = True, queue_size = 1000)'.format(topic=classname)]
        statements += ['\trospy.spin()']
        statements += ['if __name__ == \'__main__\':']
        statements += ['\tmain(sys.argv)']
        # add code to Subscribe and Publish info

        source = '\n'.join(statements)

        with open('./monitors/mtl_monitor_' + str(self.nMonitors) + '.py', 'w') as monitor:
            monitor.write(source)

        self.nMonitors += 1
        return 'kwargs[\'mtl_monitor_' + str(self.nMonitors - 1) + '\']'


    # visit the main property containing the list of propositions with their types
    # and the equations to define the tree of properties
    def visitPropertyExpr(self, ctx:StreamParser.PropertyExprContext):
        self.visit(ctx.ty) # visit the list of proposition : type
        self.visit(ctx.child) # visit the equations
        self.createClockNode()

    # visit (proposition : type)*
    def visitTyExpr(self, ctx:StreamParser.TyExprContext):
        i = 0
        for type in ctx.types():
            self.types[str(ctx.IDENTIFIER(i))] = StreamBuilder.convertToTimed(type.v.text)
            i += 1

    # visit (name = expr)
    def visitNamedExpr(self, ctx:StreamParser.NamedExprContext):
        i = 0
        # for each expression
        for expr in ctx.expr():
            label = self.visit(expr) # visit the expression
            # update expression type to be used later on
            self.types['expr(' + str(ctx.IDENTIFIER(i)) + ')'] = self.type
            # create the high level monitor which publish on name
            monitorName = 'monitor_' + str(ctx.IDENTIFIER(i))
            statements = []
            statements += ['#!/usr/bin/env python']
            statements += ['import rospy']
            statements += ['import intervals']
            statements += ['import sys']
            statements += ['from threading import *']
            statements += ['from stream.msg import *']
            statements += ['from std_msgs.msg import *']
            statements += ['']
            # create the callback on the result for the lower level monitor
            statements += ['def callback(data):']
            statements += ['\tpub.publish(data)'] # repropagate the result on the proper higher level predicate
            if self.debug:
                statements += ['\tprint(\'{topic} = \' + str(data.value))'.format(topic=ctx.IDENTIFIER(i))]
            statements += ['']
            statements += ['def main(argv):']
            statements += ['\tglobal pub']
            statements += ['\trospy.init_node(\'{monitorName}\', anonymous=True)'.format(monitorName=monitorName)]
            statements += ['\trospy.Subscriber(\'{topic}\', {ty}, callback)'.format(topic=label[8:-2], ty=self.type)]
            statements += ['\tpub = rospy.Publisher(name = \'{topic}\', data_class = {ty}, latch = True, queue_size = 1000)'.format(topic=ctx.IDENTIFIER(i), ty=self.type)]
            statements += ['\trospy.spin()']
            statements += ['if __name__ == \'__main__\':']
            statements += ['\tmain(sys.argv)']

            source = '\n'.join(statements)

            with open('./monitors/' + monitorName + '.py', 'w') as monitor:
                monitor.write(source)

            #self.nMonitors += 1
            i += 1
        return 'kwargs[\'monitor_' + str(self.nMonitors) + '\']'

    # propagate the visit to the lower expression
    def visitAtomicExpression(self, ctx:StreamParser.AtomicExpressionContext):
        self.reset()
        self.output = self.visit(ctx.child)
        if type(ctx.child) is StreamParser.EvaluationContext:
            return self.output
        else:
            return self.createMTLMonitor()

    # visit (MTLexpr and MTLexpr)
    def visitAnd(self, ctx:StreamParser.AndContext):
        self.reset()
        self.output = self.visit(ctx.left) # visit left operand
        if isinstance(ctx.left, (StreamParser.EvaluationContext, StreamParser.AndContext, StreamParser.OrContext)):
            labelL = self.output
        else:
            labelL = self.createMTLMonitor() # create the corresponding MTL monitor
        typeL = self.type
        self.reset()
        self.output = self.visit(ctx.right) # visit right operand
        if isinstance(ctx.left, (StreamParser.EvaluationContext, StreamParser.AndContext, StreamParser.OrContext)):
            labelR = self.output
        else:
            labelR = self.createMTLMonitor() # create the corresponding MTL monitor
        typeR = self.type
        operator = ' and '
        self.type = 'TimedBool'
        if labelL + operator + labelR in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelL + operator + labelR] + '\']'
        else:
            # create the composition monitor for and
            self.createCompositionMonitor('and_monitor_' + str(self.nMonitors), labelL, labelR, typeL, typeR, operator)
            self.nMonitors += 1
            self.already_seen[labelL + operator + labelR] = 'kwargs[\'and_monitor_' + str(self.nMonitors - 1) + '\']'
            return 'kwargs[\'and_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (MTLexpr or MTLexpr)
    def visitOr(self, ctx:StreamParser.OrContext):
        self.reset()
        self.output = self.visit(ctx.left) # visit left operand
        if isinstance(ctx.left, (StreamParser.EvaluationContext, StreamParser.AndContext, StreamParser.OrContext)):
            labelL = self.output
        else:
            labelL = self.createMTLMonitor() # create the corresponding MTL monitor
        typeL = self.type
        self.reset()
        self.output = self.visit(ctx.right) # visit right operand
        if isinstance(ctx.left, (StreamParser.EvaluationContext, StreamParser.AndContext, StreamParser.OrContext)):
            labelR = self.output
        else:
            labelR = self.createMTLMonitor() # create the corresponding MTL monitor
        typeR = self.type
        operator = ' or '
        self.type = 'TimedBool'
        if labelL + operator + labelR in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelL + operator + labelR] + '\']'
        else:
            # create the composition monitor for and
            self.createCompositionMonitor('or_monitor_' + str(self.nMonitors), labelL, labelR, typeL, typeR, operator)
            self.nMonitors += 1
            self.already_seen[labelL + operator + labelR] = 'kwargs[\'and_monitor_' + str(self.nMonitors - 1) + '\']'
            return 'kwargs[\'and_monitor_' + str(self.nMonitors - 1) + '\']'

    # propagate the visit to the lower expression
    def visitEvaluation(self, ctx:StreamParser.EvaluationContext):
        label = str(self.visit(ctx.child))
        return label
        # if label.startswith('kwargs'):
        #     label = label[8:-2]
        # #self.subscribers.add(label)
        # return 'kwargs[\'{}\']'.format(label)

    # propagate the visit to the lower expression
    def visitAggregation(self, ctx:StreamParser.AggregationContext):
        label = str(self.visit(ctx.child))
        return label
        # if label.startswith('kwargs'):
        #     label = label[8:-2]
        # #self.subscribers.add(label)
        # return 'kwargs[\'{}\']'.format(label)

    # visit (expr < expr)
    def visitLess(self, ctx:StreamParser.LessContext):
        labelL = self.visit(ctx.left)
        typeL = self.type
        labelR = self.visit(ctx.right)
        typeR = self.type
        operator = ' < '
        self.type = 'TimedBool'
        if labelL + operator + labelR in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelL + operator + labelR] + '\']'
        else:
            self.createCompositionMonitor('less_monitor_' + str(self.nMonitors), labelL, labelR, typeL, typeR, ' < ')
            self.already_seen[labelL + operator + labelR] = 'less_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'less_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (expr <= expr)
    def visitLessEq(self, ctx:StreamParser.LessEqContext):
        labelL = self.visit(ctx.left)
        typeL = self.type
        labelR = self.visit(ctx.right)
        typeR = self.type
        operator = ' <= '
        self.type = 'TimedBool'
        if labelL + operator + labelR in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelL + operator + labelR] + '\']'
        else:
            self.createCompositionMonitor('less_eq_monitor_' + str(self.nMonitors), labelL, labelR, typeL, typeR, operator)
            self.already_seen[labelL + operator + labelR] = 'less_eq_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'less_eq_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (expr > expr)
    def visitGreater(self, ctx:StreamParser.GreaterContext):
        labelL = self.visit(ctx.left)
        typeL = self.type
        labelR = self.visit(ctx.right)
        typeR = self.type
        operator = ' > '
        self.type = 'TimedBool'
        if labelL + operator + labelR in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelL + operator + labelR] + '\']'
        else:
            self.createCompositionMonitor('greater_monitor_' + str(self.nMonitors), labelL, labelR, typeL, typeR, operator)
            self.already_seen[labelL + operator + labelR] = 'greater_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'greater_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (expr >= expr)
    def visitGreaterEq(self, ctx:StreamParser.GreaterEqContext):
        labelL = self.visit(ctx.left)
        typeL = self.type
        labelR = self.visit(ctx.right)
        typeR = self.type
        operator = ' >= '
        self.type = 'TimedBool'
        if labelL + operator + labelR in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelL + operator + labelR] + '\']'
        else:
            self.createCompositionMonitor('greater_eq_monitor_' + str(self.nMonitors), labelL, labelR, typeL, typeR, operator)
            self.already_seen[labelL + operator + labelR] = 'greater_eq_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'greater_eq_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (expr == expr)
    def visitEq(self, ctx:StreamParser.EqContext):
        labelL = self.visit(ctx.left)
        typeL = self.type
        labelR = self.visit(ctx.right)
        typeR = self.type
        operator = ' == '
        self.type = 'TimedBool'
        if labelL + operator + labelR in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelL + operator + labelR] + '\']'
        else:
            self.createCompositionMonitor('eq_monitor_' + str(self.nMonitors), labelL, labelR, typeL, typeR, operator)
            self.already_seen[labelL + operator + labelR] = 'eq_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'eq_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (expr != expr)
    def visitNeq(self, ctx:StreamParser.NeqContext):
        labelL = self.visit(ctx.left)
        typeL = self.type
        labelR = self.visit(ctx.right)
        typeR = self.type
        operator = ' != '
        self.type = 'TimedBool'
        if labelL + operator + labelR in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelL + operator + labelR] + '\']'
        else:
            self.createCompositionMonitor('neq_monitor_' + str(self.nMonitors), labelL, labelR, typeL, typeR, operator)
            self.already_seen[labelL + operator + labelR] = 'neq_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'neq_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (min expr)
    def visitMin(self, ctx:StreamParser.MinContext):
        label = self.visit(ctx.child)
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['minimum = None']
        statements += ['def aggregate(time, lastValue):']
        statements += ['\tglobal minimum']
        statements += ['\tif minimum is None or lastValue < minimum:']
        statements += ['\t\tminimum = lastValue']
        statements += ['\treturn minimum']

        aggrFunc = '\n'.join(statements)

        if 'min' + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['min' + label] + '\']'
        else:
            self.createAggregationMonitor('min_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['min' + label] = 'min_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'min_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (min [l] expr)
    def visitTimedMin(self, ctx:StreamParser.TimedMinContext):
        label = self.visit(ctx.child)
        interval = ctx.l.text
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['from queue import *']
        statements += ['values = Queue()']
        statements += ['lastTime = None']
        statements += ['lastValue = None']
        statements += ['def aggregate(time, value):']
        statements += ['\tglobal lastTime, lastValue']
        statements += ['\tif lastTime is None:']
        statements += ['\t\tlastTime = time - 1']
        statements += ['\t\tfor i in range(0, {interval}):'.format(interval=interval)]
        statements += ['\t\t\tvalues.put(value)']
        statements += ['\twhile (time - lastTime) > 1:']
        statements += ['\t\tvalues.put(lastValue)']
        statements += ['\t\tlastTime += 1']
        statements += ['\tvalues.put(value)']
        statements += ['\twhile values.qsize() > {interval}:'.format(interval=interval)]
        statements += ['\t\tvalues.get()']
        statements += ['\tminimum = None']
        statements += ['\tfor i in range({interval}):'.format(interval=interval)]
        statements += ['\t\tv = values.get()']
        statements += ['\t\tvalues.put(v)']
        statements += ['\t\tif minimum is None or v < minimum:']
        statements += ['\t\t\tminimum = v']
        statements += ['\tlastValue = value']
        statements += ['\tlastTime += 1']
        statements += ['\treturn minimum']


        aggrFunc = '\n'.join(statements)

        if 'tmin' + interval + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['tmin' + interval + label] + '\']'
        else:
            self.createAggregationMonitor('tmin_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['tmin' + interval + label] = 'tmin_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'tmin_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (max expr)
    def visitMax(self, ctx:StreamParser.MaxContext):
        label = self.visit(ctx.child)
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['maximum = None']
        statements += ['def aggregate(time, lastValue):']
        statements += ['\tglobal maximum']
        statements += ['\tif maximum is None or lastValue > maximum:']
        statements += ['\t\tmaximum = lastValue']
        statements += ['\treturn maximum']

        aggrFunc = '\n'.join(statements)

        if 'max' + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['max' + label] + '\']'
        else:
            self.createAggregationMonitor('max_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['max' + label] = 'max_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'max_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (max [l] expr)
    def visitTimedMax(self, ctx:StreamParser.TimedMaxContext):
        label = self.visit(ctx.child)
        interval = ctx.l.text
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['from queue import *']
        statements += ['values = Queue()']
        statements += ['lastTime = None']
        statements += ['lastValue = None']
        statements += ['def aggregate(time, value):']
        statements += ['\tglobal lastTime, lastValue']
        statements += ['\tif lastTime is None:']
        statements += ['\t\tlastTime = time - 1']
        statements += ['\t\tfor i in range(0, {interval}):'.format(interval=interval)]
        statements += ['\t\t\tvalues.put(value)']
        statements += ['\twhile (time - lastTime) > 1:']
        statements += ['\t\tvalues.put(lastValue)']
        statements += ['\t\tlastTime += 1']
        statements += ['\tvalues.put(value)']
        statements += ['\twhile values.qsize() > {interval}:'.format(interval=interval)]
        statements += ['\t\tvalues.get()']
        statements += ['\tmaximum = None']
        statements += ['\tfor i in range({interval}):'.format(interval=interval)]
        statements += ['\t\tv = values.get()']
        statements += ['\t\tvalues.put(v)']
        statements += ['\t\tif maximum is None or v > maximum:']
        statements += ['\t\t\tmaximum = v']
        statements += ['\tlastValue = value']
        statements += ['\tlastTime += 1']
        statements += ['\treturn maximum']


        aggrFunc = '\n'.join(statements)

        if 'tmax' + interval + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['tmax' + interval + label] + '\']'
        else:
            self.createAggregationMonitor('tmax_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['tmax' + interval + label] = 'tmax_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'tmax_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (avg expr)
    def visitAvg(self, ctx:StreamParser.AvgContext):
        label = self.visit(ctx.child)
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['avg = 0']
        statements += ['count = 0']
        statements += ['def aggregate(time, lastValue):']
        statements += ['\tglobal avg, count']
        statements += ['\tcount += 1']
        statements += ['\tavg = avg + (lastValue - avg) / count']
        statements += ['\treturn avg']

        aggrFunc = '\n'.join(statements)

        if 'avg' + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['avg' + label] + '\']'
        else:
            self.createAggregationMonitor('avg_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['avg' + label] = 'avg_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'avg_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (avg [l] expr)
    def visitTimedAvg(self, ctx:StreamParser.TimedAvgContext):
        label = self.visit(ctx.child)
        interval = ctx.l.text
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['from queue import *']
        statements += ['values = Queue()']
        statements += ['lastTime = None']
        statements += ['lastValue = None']
        statements += ['def aggregate(time, value):']
        statements += ['\tglobal lastTime, lastValue']
        statements += ['\tif lastTime is None:']
        statements += ['\t\tlastTime = time - 1']
        statements += ['\t\tfor i in range(0, {interval}):'.format(interval=interval)]
        statements += ['\t\t\tvalues.put(value)']
        statements += ['\twhile (time - lastTime) > 1:']
        statements += ['\t\tvalues.put(lastValue)']
        statements += ['\t\tlastTime += 1']
        statements += ['\tvalues.put(value)']
        statements += ['\twhile values.qsize() > {interval}:'.format(interval=interval)]
        statements += ['\t\tvalues.get()']
        statements += ['\tavg = 0']
        statements += ['\tfor i in range({interval}):'.format(interval)]
        statements += ['\t\tv = values.get()']
        statements += ['\t\tvalues.put(v)']
        statements += ['\t\tavg = avg + (v - avg) / (i + 1)']
        statements += ['\tlastValue = value']
        statements += ['\tlastTime += 1']
        statements += ['\treturn avg']

        aggrFunc = '\n'.join(statements)

        if 'tavg' + interval + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['tavg' + interval + label] + '\']'
        else:
            self.createAggregationMonitor('tavg_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['tavg' + interval + label] = 'tavg_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'tavg_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (diff expr)
    def visitTimedDiff(self, ctx:StreamParser.TimedDiffContext):
        label = self.visit(ctx.child)
        interval = ctx.l.text
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['from queue import *']
        statements += ['values = Queue()']
        statements += ['lastTime = None']
        statements += ['lastValue = None']
        statements += ['def aggregate(time, value):']
        statements += ['\tglobal lastTime, lastValue']
        statements += ['\tif lastTime is None:']
        statements += ['\t\tlastTime = time - 1']
        statements += ['\t\tfor i in range(0, {interval}):'.format(interval=interval)]
        statements += ['\t\t\tvalues.put(value)']
        statements += ['\twhile (time - lastTime) > 1:']
        statements += ['\t\tvalues.put(lastValue)']
        statements += ['\t\tlastTime += 1']
        statements += ['\tvalues.put(value)']
        statements += ['\twhile values.qsize() > {interval}:'.format(interval=interval)]
        statements += ['\t\tlastRemoved = values.get()']
        statements += ['\tlastValue = value']
        statements += ['\tlastTime += 1']
        statements += ['\treturn value - lastRemoved']


        aggrFunc = '\n'.join(statements)

        if 'tdiff' + interval + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['tdiff' + interval + label] + '\']'
        else:
            self.createAggregationMonitor('tdiff_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['tdiff' + interval + label] = 'tdiff_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'tdiff_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (diff expr1 expr2)
    def visitTwoStreamDiff(self, ctx:StreamParser.TwoStreamDiffContext):
        labelF = self.visit(ctx.first)
        typeF = self.type
        labelS = self.visit(ctx.second)
        typeS = self.type
        operator = ' - '
        if typeF == 'TimedReal' or typeS == 'TimedReal':
            self.type = 'TimedReal'
        else:
            self.type = 'TimedInt'
        if labelF + operator + labelS in self.already_seen:
            return 'kwargs[\'' + self.already_seen[labelF + operator + labelS] + '\']'
        else:
            self.createCompositionMonitor('two_stream_diff_monitor_' + str(self.nMonitors), labelF, labelS, typeF, typeS, operator)
            self.already_seen[labelF + operator + labelS] = 'two_stream_diff_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'two_stream_diff_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (delta expr)
    def visitDelta(self, ctx:StreamParser.DeltaContext):
        label = self.visit(ctx.child)
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['avg = 0']
        statements += ['delta = 0']
        statements += ['count = 0']
        statements += ['def aggregate(time, lastValue):']
        statements += ['\tglobal avg, delta, count']
        statements += ['\tcount += 1']
        statements += ['\tavgOld = avg']
        statements += ['\tavg = avg + (lastValue - avg) / count']
        statements += ['\tdelta = delta + (lastValue - avgOld) * (lastValue - avg)']
        statements += ['\treturn math.sqrt(delta / count)']

        aggrFunc = '\n'.join(statements)

        if 'delta' + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['delta' + label] + '\']'
        else:
            self.createAggregationMonitor('delta_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['delta' + label] = 'delta_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'delta_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (delta [l] expr)
    def visitTimedDelta(self, ctx:StreamParser.TimedDeltaContext):
        label = self.visit(ctx.child)
        interval = ctx.l.text
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['from queue import *']
        statements += ['values = Queue()']
        statements += ['lastTime = None']
        statements += ['lastValue = None']
        statements += ['def aggregate(time, value):']
        statements += ['\tglobal lastTime, lastValue']
        statements += ['\tif lastTime is None:']
        statements += ['\t\tlastTime = time - 1']
        statements += ['\t\tfor i in range(0, {interval}):'.format(interval=interval)]
        statements += ['\t\t\tvalues.put(value)']
        statements += ['\twhile (time - lastTime) > 1:']
        statements += ['\t\tvalues.put(lastValue)']
        statements += ['\t\tlastTime += 1']
        statements += ['\tvalues.put(value)']
        statements += ['\twhile values.qsize() > {interval}:'.format(interval=interval)]
        statements += ['\t\tvalues.get()']
        statements += ['\tavg = 0']
        statements += ['\tfor i in range({interval}):'.format(interval=interval)]
        statements += ['\t\tv = values.get()']
        statements += ['\t\tvalues.put(v)']
        statements += ['\t\tavg = avg + (v - avg) / (i + 1)']
        statements += ['\tsum = 0']
        statements += ['\tfor i in range({interval}):'.format(interval=interval)]
        statements += ['\t\tv = values.get()']
        statements += ['\t\tvalues.put(v)']
        statements += ['\t\tsum += (v - avg) ** 2']
        statements += ['\tlastValue = value']
        statements += ['\tlastTime += 1']
        statements += ['\treturn math.sqrt(sum / {interval})'.format(interval=interval)]

        aggrFunc = '\n'.join(statements)

        if 'tdelta' + interval + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['tdelta' + interval + label] + '\']'
        else:
            self.createAggregationMonitor('tdelta_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['tdelta' + interval + label] = 'tdelta_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'tdelta_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (count expr)
    def visitCount(self, ctx:StreamParser.CountContext):
        label = self.visit(ctx.child)
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['count = 0']
        statements += ['def aggregate(time, lastValue):']
        statements += ['\tglobal count']
        statements += ['\tif lastValue:']
        statements += ['\t\tcount = count + 1']
        statements += ['\treturn count']

        aggrFunc = '\n'.join(statements)

        if 'count' + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['count' + label] + '\']'
        else:
            self.createAggregationMonitor('count_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['count' + label] = 'count_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'count_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit (count [l] expr)
    def visitTimedCount(self, ctx:StreamParser.TimedCountContext):
        label = self.visit(ctx.child)
        interval = ctx.l.text
        # create the aggregation function to pass to the aggregation monitor creator
        statements = []
        statements += ['from queue import *']
        statements += ['values = Queue()']
        statements += ['lastTime = None']
        statements += ['lastValue = None']
        statements += ['def aggregate(time, value):']
        statements += ['\tglobal lastTime, lastValue']
        statements += ['\tif lastTime is None:']
        statements += ['\t\tlastTime = time - 1']
        statements += ['\t\tfor i in range(0, {interval}):'.format(interval=interval)]
        statements += ['\t\t\tvalues.put(value)']
        statements += ['\twhile (time - lastTime) > 1:']
        statements += ['\t\tvalues.put(lastValue)']
        statements += ['\t\tlastTime += 1']
        statements += ['\tvalues.put(value)']
        statements += ['\twhile values.qsize() > {interval}:'.format(interval=interval)]
        statements += ['\t\tvalues.get()']
        statements += ['\tcount = 0']
        statements += ['\tfor i in range({interval}):'.format(interval=interval)]
        statements += ['\t\tv = values.get()']
        statements += ['\t\tvalues.put(v)']
        statements += ['\t\tif v:']
        statements += ['\t\t\tcount = count + 1']
        statements += ['\tlastValue = value']
        statements += ['\tlastTime += 1']
        statements += ['\treturn count']

        aggrFunc = '\n'.join(statements)

        if 'tcount' + interval + label in self.already_seen:
            return 'kwargs[\'' + self.already_seen['tcount' + interval + label] + '\']'
        else:
            self.createAggregationMonitor('tcount_monitor_' + str(self.nMonitors), aggrFunc, self.type, label)
            self.already_seen['tcount' + interval + label] = 'tcount_monitor_' + str(self.nMonitors)
            self.nMonitors += 1
            return 'kwargs[\'tcount_monitor_' + str(self.nMonitors - 1) + '\']'

    # visit atomic proposition
    def visitProp(self, ctx:StreamParser.PropContext):
        name = ctx.name.text

        if name in self.types:
            if name in self.already_seen:
                return 'kwargs[\'' + self.already_seen[name] + '\']'

            self.type = self.types[name]

            monitorName = 'monitor_' + name

            statements = []
            statements += ['#!/usr/bin/env python']
            statements += ['import rospy']
            statements += ['import intervals']
            statements += ['import sys']
            statements += ['from threading import *']
            statements += ['from stream.msg import *']
            statements += ['from std_msgs.msg import *']
            statements += ['']
            statements += ['ws_lock = Lock()']
            statements += ['last = None']
            # create a callback for the proposition
            statements += ['def callback(data):']
            statements += ['\tglobal last']
            statements += ['\tws_lock.acquire()']
            statements += ['\tlast = data.data']
            statements += ['\tws_lock.release()']
            # create a callback for the clock (in order to sample the data accordingly)
            statements += ['def callbackClock(data):']
            statements += ['\tws_lock.acquire()']
            statements += ['\tif last is not None: ']
            statements += ['\t\tmsg = {ty}()'.format(ty=self.type)]
            statements += ['\t\tmsg.time = data.data']
            statements += ['\t\tmsg.value = last']
            statements += ['\t\tpub.publish(msg)'] # republish last observed data
            statements += ['\tws_lock.release()']
            statements += ['']
            statements += ['def main(argv):']
            statements += ['\tglobal pub']
            statements += ['\trospy.init_node(\'{monitorName}\', anonymous=True)'.format(monitorName=monitorName)]
            # subscribe on the proposition
            statements += ['\trospy.Subscriber(\'{topic}\', {ty}, callback)'.format(topic=name, ty=StreamBuilder.convert(self.type))]
            statements += ['\trospy.Subscriber(\'stream_clock\', Int64, callbackClock)']
            # publish on an updated topic (adding '_' to the topic name)
            statements += ['\tpub = rospy.Publisher(name = \'{topic}\', data_class = {ty}, latch = True, queue_size = 1000)'.format(topic=name+'_', ty=self.type)]
            statements += ['\trospy.spin()']
            statements += ['if __name__ == \'__main__\':']
            statements += ['\tmain(sys.argv)']

            source = '\n'.join(statements)

            with open('./monitors/' + monitorName + '.py', 'w') as monitor:
                monitor.write(source)

            #self.nMonitors += 1

            return 'kwargs[\'{}\']'.format(name + '_')
        else:
            return 'kwargs[\'{}\']'.format(name)

    # visit integer
    def visitInt(self, ctx:StreamParser.IntContext):
        self.type = 'TimedInt'
        return ctx.child.text

    # visit real
    def visitReal(self, ctx:StreamParser.RealContext):
        self.type = 'TimedReal'
        return ctx.child.text

    # visit predicate (maybe to be removed)
    def visitPred(self, ctx:StreamParser.PredContext):
        name = ctx.name.text
        args = ctx.args.getText().split(',')
        nargs = ['kwargs[\'{}\']'.format(arg) for arg in args]

        return '{name}({params})'.format(name=name, params=', '.join(nargs))

    # visit (not expr)
    def visitNegation(self, ctx:StreamParser.NegationContext):
        child = self.visit(ctx.child)
        label = 'self.states[{}]'.format(self.num)

        self.initialization.append(False)
        self.statements.append('{} = not({});'.format(label, child))
        self.num = self.num + 1

        return label

    # visit (expr || expr)
    def visitDisjunction(self, ctx:StreamParser.DisjunctionContext):
        left = self.visit(ctx.left)
        right = self.visit(ctx.right)
        label = 'self.states[{}]'.format(self.num)

        self.initialization.append(False)
        self.statements.append('{} = {} or {};'.format(label, left, right))
        self.num = self.num + 1

        return label

    # visit (expr && expr)
    def visitConjunction(self, ctx:StreamParser.ConjunctionContext):
        left = self.visit(ctx.left)
        right = self.visit(ctx.right)
        label = 'self.states[{}]'.format(self.num)

        self.initialization.append(False)
        self.statements.append('{} = {} and {};'.format(label, left, right))
        self.num = self.num + 1

        return label

    # visit (expr -> expr)
    def visitImplies(self, ctx:StreamParser.ImpliesContext):
        left = self.visit(ctx.left)
        right = self.visit(ctx.right)
        label = 'self.states[{}]'.format(self.num)

        self.initialization.append(False)
        self.statements.append('{} = not {} or {};'.format(label, left, right))
        self.num = self.num + 1

        return label

    # visit (pre expr)
    def visitPreviously(self, ctx:StreamParser.PreviouslyContext):
        child = self.visit(ctx.child)
        label = 'self.states[{}]'.format(self.num)

        min_val = 1
        max_val = 1

        self.initialization.append('intervals.empty()')
        self.statements.append('{label} = self.update_timed_since(self.time, {label}, True, {right}, {min_val}, {max_val})'.format(label=label, right=child, min_val=min_val, max_val=max_val))
        self.num = self.num + 1

        return 'self.output_timed({})'.format(label)

    # visit (expr since expr)
    def visitSince(self, ctx:StreamParser.SinceContext):
        left = self.visit(ctx.left)
        right = self.visit(ctx.right)
        label = 'self.states[{}]'.format(self.num)

        self.initialization.append(False)
        self.statements.append('{label} = {right} or ({left} and {label});'.format(label=label, left=left, right=right))
        self.num = self.num + 1

        return label

    # visit (expr since [l,u] expr)
    def visitTimedSince(self, ctx:StreamParser.TimedSinceContext):
        left = self.visit(ctx.left)
        right = self.visit(ctx.right)

        min_val = ctx.l.text
        max_val = ctx.u.text

        label = 'self.states[{}]'.format(self.num)
        self.initialization.append('intervals.empty()')
        self.statements.append('{label} = self.update_timed_since(self.time, {label}, {left}, {right}, {min_val}, {max_val})'.format(label=label, left=left, right=right, min_val=min_val, max_val=max_val))
        self.num = self.num + 1

        return 'self.output_timed({})'.format(label)

    # visit (expr since [l,inf] expr)
    def visitTimedSinceInf(self, ctx:StreamParser.TimedSinceInfContext):
        left = self.visit(ctx.left)
        right = self.visit(ctx.right)

        min_val = ctx.l.text

        label = 'self.states[{}]'.format(self.num)
        self.initialization.append('intervals.empty()')
        self.statements.append('{label} = self.update_timed_since_inf(self.time, {label}, {left}, {right}, {min_val})'.format(label=label, left=left, right=right, min_val=min_valdInf))
        self.num = self.num + 1

        return 'self.output_timed({})'.format(label)
    # visit (always expr)
    def visitAlways(self, ctx:StreamParser.AlwaysContext):
        child = self.visit(ctx.child)
        label = 'self.states[{}]'.format(self.num)

        self.initialization.append(True)
        self.statements.append('{label} = {label} and {child};'.format(label=label, child=child))
        self.num = self.num + 1

        return label

    # visit (always [l,u] expr)
    def visitTimedAlways(self, ctx:StreamParser.TimedAlwaysContext):
        child = self.visit(ctx.child)
        label = 'self.states[{}]'.format(self.num)

        min_val = ctx.l.text
        max_val = ctx.u.text

        self.initialization.append('intervals.empty()')
        self.statements.append('{label} = self.update_timed_since(self.time, {label}, True, not {right}, {min_val}, {max_val})'.format(label=label, right=child, min_val=min_val, max_val=max_val))
        self.num = self.num + 1

        return 'not(self.output_timed({}))'.format(label)

    # visit (always [l,inf] expr)
    def visitTimedAlwaysInf(self, ctx:StreamParser.TimedAlwaysInfContext):
        child = self.visit(ctx.child)
        label = 'self.states[{}]'.format(self.num)

        min_val = ctx.l.text

        self.initialization.append('intervals.empty()')
        self.statements.append('{label} = self.update_timed_since_inf(self.time, {label}, True, not {right}, {min_val})'.format(label=label, right=child, min_val=min_val))
        self.num = self.num + 1

        return 'not(self.output_timed({}))'.format(label)

    # visit (once expr)
    def visitOnce(self, ctx:StreamParser.OnceContext):
        child = self.visit(ctx.child)
        label = 'self.states[{}]'.format(self.num)

        self.initialization.append(list())
        self.statements.append('{label} = {label} or {child};'.format(label=label, child=child))
        self.num = self.num + 1

        return label

    # visit (once [l,u] expr)
    def visitTimedOnce(self, ctx:StreamParser.TimedOnceContext):
        child = self.visit(ctx.child)
        label = 'self.states[{}]'.format(self.num)

        min_val = ctx.l.text
        max_val = ctx.u.text

        self.initialization.append('intervals.empty()')
        self.statements.append('{label} = self.update_timed_since(self.time, {label}, True, {right}, {min_val}, {max_val})'.format(label=label, right=child, min_val=min_val, max_val=max_val))
        self.num = self.num + 1

        return 'self.output_timed({})'.format(label)

    # visit (once [l,inf] expr)
    def visitTimedOnceInf(self, ctx:StreamParser.TimedOnceInfContext):
        child = self.visit(ctx.child)
        label = 'self.states[{}]'.format(self.num)

        min_val = ctx.l.text

        self.initialization.append('intervals.empty()')
        self.statements.append('{label} = self.update_timed_since_inf(self.time, {label}, True, {right}, {min_val})'.format(label=label, right=child, min_val=min_val))
        self.num = self.num + 1

        return 'self.output_timed({})'.format(label)

    # Visit a parse tree produced by StreamParser#Grouping.
    def visitGrouping(self, ctx:StreamParser.GroupingContext):
        return self.visit(ctx.child)
    # def visitGrouping2(self, ctx:StreamParser.Grouping2Context):
    #     return self.visit(ctx.child)
    # def visitGrouping3(self, ctx:StreamParser.Grouping3Context):
    #     return self.visit(ctx.child)
